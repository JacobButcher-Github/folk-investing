// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: stocks.sql

package db

import (
	"context"
	"database/sql"
	"strings"
)

const createStock = `-- name: CreateStock :one
INSERT INTO
  stocks (name, image_path)
VALUES
  (?, ?) RETURNING id, name, image_path
`

type CreateStockParams struct {
	Name      string `json:"name"`
	ImagePath string `json:"image_path"`
}

func (q *Queries) CreateStock(ctx context.Context, arg CreateStockParams) (Stock, error) {
	row := q.db.QueryRowContext(ctx, createStock, arg.Name, arg.ImagePath)
	var i Stock
	err := row.Scan(&i.ID, &i.Name, &i.ImagePath)
	return i, err
}

const createStockData = `-- name: CreateStockData :one
INSERT INTO
  stock_data (stock_id, event_label, value_dollars, value_cents)
VALUES
  (?, ?, ?, ?) RETURNING id, stock_id, event_label, value_dollars, value_cents
`

type CreateStockDataParams struct {
	StockID      int64  `json:"stock_id"`
	EventLabel   string `json:"event_label"`
	ValueDollars int64  `json:"value_dollars"`
	ValueCents   int64  `json:"value_cents"`
}

func (q *Queries) CreateStockData(ctx context.Context, arg CreateStockDataParams) (StockDatum, error) {
	row := q.db.QueryRowContext(ctx, createStockData,
		arg.StockID,
		arg.EventLabel,
		arg.ValueDollars,
		arg.ValueCents,
	)
	var i StockDatum
	err := row.Scan(
		&i.ID,
		&i.StockID,
		&i.EventLabel,
		&i.ValueDollars,
		&i.ValueCents,
	)
	return i, err
}

const deleteStock = `-- name: DeleteStock :exec
DELETE FROM stocks
WHERE
  name = ?
`

func (q *Queries) DeleteStock(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, deleteStock, name)
	return err
}

const getAllStocks = `-- name: GetAllStocks :many
SELECT
  id, name, image_path
FROM
  STOCKS
`

func (q *Queries) GetAllStocks(ctx context.Context) ([]Stock, error) {
	rows, err := q.db.QueryContext(ctx, getAllStocks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Stock{}
	for rows.Next() {
		var i Stock
		if err := rows.Scan(&i.ID, &i.Name, &i.ImagePath); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockData = `-- name: GetStockData :one
SELECT
  id, stock_id, event_label, value_dollars, value_cents
FROM
  stock_data
WHERE
  stock_id = ?
ORDER BY
  id ASC
LIMIT
  ?
`

type GetStockDataParams struct {
	StockID int64 `json:"stock_id"`
	Limit   int64 `json:"limit"`
}

func (q *Queries) GetStockData(ctx context.Context, arg GetStockDataParams) (StockDatum, error) {
	row := q.db.QueryRowContext(ctx, getStockData, arg.StockID, arg.Limit)
	var i StockDatum
	err := row.Scan(
		&i.ID,
		&i.StockID,
		&i.EventLabel,
		&i.ValueDollars,
		&i.ValueCents,
	)
	return i, err
}

const getStockDataByLabel = `-- name: GetStockDataByLabel :many
SELECT
  id, stock_id, event_label, value_dollars, value_cents
FROM
  stock_data
WHERE
  event_label = ?
`

// Get all data for stocks with a certain label.
func (q *Queries) GetStockDataByLabel(ctx context.Context, eventLabel string) ([]StockDatum, error) {
	rows, err := q.db.QueryContext(ctx, getStockDataByLabel, eventLabel)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StockDatum{}
	for rows.Next() {
		var i StockDatum
		if err := rows.Scan(
			&i.ID,
			&i.StockID,
			&i.EventLabel,
			&i.ValueDollars,
			&i.ValueCents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockFromId = `-- name: GetStockFromId :one
SELECT
  id, name, image_path
FROM
  stocks
WHERE
  id = ?
LIMIT
  1
`

func (q *Queries) GetStockFromId(ctx context.Context, id int64) (Stock, error) {
	row := q.db.QueryRowContext(ctx, getStockFromId, id)
	var i Stock
	err := row.Scan(&i.ID, &i.Name, &i.ImagePath)
	return i, err
}

const getStockFromName = `-- name: GetStockFromName :one
SELECT
  id, name, image_path
FROM
  stocks
WHERE
  name = ?
LIMIT
  1
`

func (q *Queries) GetStockFromName(ctx context.Context, name string) (Stock, error) {
	row := q.db.QueryRowContext(ctx, getStockFromName, name)
	var i Stock
	err := row.Scan(&i.ID, &i.Name, &i.ImagePath)
	return i, err
}

const getStocksData = `-- name: GetStocksData :many
SELECT
  sd.id, sd.stock_id, sd.event_label, sd.value_dollars, sd.value_cents
FROM
  stock_data sd
WHERE
  sd.stock_id IN (/*SLICE:stock_ids*/?)
  AND sd.id IN (
    SELECT
      id
    FROM
      stock_data
    WHERE
      stock_id = sd.stock_id
    ORDER BY
      id ASC
    LIMIT
      ?
  )
ORDER BY
  sd.value_dollars,
  sd.value_cents
`

type GetStocksDataParams struct {
	StockIds []int64 `json:"stock_ids"`
	Limit    int64   `json:"limit"`
}

// Get all data for stocks up to a limit. Meant for use by the graph  on the main page.
func (q *Queries) GetStocksData(ctx context.Context, arg GetStocksDataParams) ([]StockDatum, error) {
	query := getStocksData
	var queryParams []interface{}
	if len(arg.StockIds) > 0 {
		for _, v := range arg.StockIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:stock_ids*/?", strings.Repeat(",?", len(arg.StockIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:stock_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.Limit)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StockDatum{}
	for rows.Next() {
		var i StockDatum
		if err := rows.Scan(
			&i.ID,
			&i.StockID,
			&i.EventLabel,
			&i.ValueDollars,
			&i.ValueCents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pruneStockData = `-- name: PruneStockData :exec
DELETE FROM stock_data
WHERE
  stock_data.stock_id = ?
  AND stock_data.id NOT IN (
    SELECT
      sd.id
    FROM
      stock_data as sd
    WHERE
      sd.stock_id = ?
    ORDER BY
      sd.id DESC
    LIMIT
      ?
  )
`

type PruneStockDataParams struct {
	StockID   int64 `json:"stock_id"`
	StockID_2 int64 `json:"stock_id_2"`
	Limit     int64 `json:"limit"`
}

func (q *Queries) PruneStockData(ctx context.Context, arg PruneStockDataParams) error {
	_, err := q.db.ExecContext(ctx, pruneStockData, arg.StockID, arg.StockID_2, arg.Limit)
	return err
}

const updateStock = `-- name: UpdateStock :one
UPDATE stocks
SET
  name = COALESCE(?1, name),
  image_path = COALESCE(?2, image_path)
WHERE
  name = ?3 RETURNING id, name, image_path
`

type UpdateStockParams struct {
	NewName   sql.NullString `json:"new_name"`
	ImagePath sql.NullString `json:"image_path"`
	Name      string         `json:"name"`
}

func (q *Queries) UpdateStock(ctx context.Context, arg UpdateStockParams) (Stock, error) {
	row := q.db.QueryRowContext(ctx, updateStock, arg.NewName, arg.ImagePath, arg.Name)
	var i Stock
	err := row.Scan(&i.ID, &i.Name, &i.ImagePath)
	return i, err
}

const updateStockData = `-- name: UpdateStockData :one
UPDATE stock_data
SET
  stock_id = COALESCE(?1, stock_id),
  event_label = COALESCE(?2, event_label),
  value_dollars = COALESCE(?3, value_dollars),
  value_cents = COALESCE(?4, value_cents)
WHERE
  stock_id = ?5
  AND event_label = ?6 RETURNING id, stock_id, event_label, value_dollars, value_cents
`

type UpdateStockDataParams struct {
	NewID        sql.NullInt64  `json:"new_id"`
	NewLabel     sql.NullString `json:"new_label"`
	ValueDollars sql.NullInt64  `json:"value_dollars"`
	ValueCents   sql.NullInt64  `json:"value_cents"`
	StockID      int64          `json:"stock_id"`
	EventLabel   string         `json:"event_label"`
}

func (q *Queries) UpdateStockData(ctx context.Context, arg UpdateStockDataParams) (StockDatum, error) {
	row := q.db.QueryRowContext(ctx, updateStockData,
		arg.NewID,
		arg.NewLabel,
		arg.ValueDollars,
		arg.ValueCents,
		arg.StockID,
		arg.EventLabel,
	)
	var i StockDatum
	err := row.Scan(
		&i.ID,
		&i.StockID,
		&i.EventLabel,
		&i.ValueDollars,
		&i.ValueCents,
	)
	return i, err
}
